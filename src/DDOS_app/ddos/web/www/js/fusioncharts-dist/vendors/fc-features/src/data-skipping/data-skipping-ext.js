import filterAPI from'./data-skipping-filters';import{filterType}from'./data-skipping-charts';import{pluckNumber}from'../../../fc-core/src/lib';const ALLOWED_RATIO_FOR_SKIPPING=1.5;let hashMapping=[],prevDataLen=0,skipConf={},dragHashMap=[];function elemHideDecider(a=[]){return a.filter(a=>!hashMapping[a])}function getBeforeSkippingDrawMap(a=0){return Array.from(Array(a),(a,b)=>b)}function decideSkip(a={}){let b,c,d,e,f,g=a.component,h=a.compType,i=g.getFromEnv('chartConfig'),j=g.getFromEnv('dataSource'),k=j.chart||{},l=pluckNumber(k.plotbinsize,i.plotbinsize),m=pluckNumber(k.labelbinsize,i.labelbinsize),n=g.getFromEnv('chartWidth'),o=g.getFromEnv('chartHeight');return skipConf.plotBinSize=l,skipConf.labelBinSize=m,skipConf.jsonData=g.config.JSONData,'group'===h?(b=skipConf.jsonData[0].data,prevDataLen=g.config.stackValues&&g.config.stackValues.length||0):'dataset'===h&&(b=skipConf.jsonData.data,prevDataLen=g.components.data&&g.components.data.length||0),c=b&&b.length,hashMapping=[],skipConf.width=f=g.getFromEnv('chart').isBar?a.height||o:a.width||n,d=c/f,e=Math.floor(d*l),!!(d>=ALLOWED_RATIO_FOR_SKIPPING&&1<e)&&(skipConf.plotsPerBin=e,skipConf.noOfPlotBins=Math.ceil(c/skipConf.plotsPerBin),!0)}function plotDrawIndices(a,b){let c=0,d=0,e=[];for(let f=1;f<skipConf.noOfPlotBins;++f)c=d,d+=skipConf.plotsPerBin,a(c,d-1,b,dragHashMap,e);return a(d,b.length-1,b,dragHashMap,e),dragHashMap=[],e}function labelDrawIndices(a){let b,c=skipConf.plotBinSize,d=skipConf.labelBinSize,e=[],f=[],g=a.length;for(b=0;b<g;b++)b%(d/c)||(e.push(a[b]),f[a[b]]=!0);return{drawableLabelIndices:e,labelHashMap:f}}function skippingTool(a){let b,c,d,e,f,g,h=a.datasetType,k=filterType[h],l=a.component,m=l.getSkippingInfo&&l.getSkippingInfo(),n=m&&m.draw.slice(0),o=m&&(m.labelDraw||[]).slice(0),p={},q=[],r=l.getFromEnv('xAxis').getTicksLen();if(n&&n.length||(n=getBeforeSkippingDrawMap(prevDataLen)),o&&o.length||(o=n),dragHashMap=m&&m.dragHashMap,'cartesianStackGroup'===l.getName()){for(e=skipConf.jsonData.length,b=0;b<r;++b){for(d=0,c=0;c<e;++c)g=skipConf.jsonData[c].data,d+=+(g[b]?g[b].value:0);q.push({value:d})}p.draw=plotDrawIndices(filterAPI(k),q)}else p.draw=plotDrawIndices(filterAPI(k),skipConf.jsonData.data);return p.draw.forEach(a=>{hashMapping[a]=!0}),p.drawOnlyMap=hashMapping,p.hide=elemHideDecider(n),f=labelDrawIndices(p.draw),p.labelDraw=f.drawableLabelIndices,hashMapping=p.labelDrawOnlyMap=f.labelHashMap,p.hideLabel=elemHideDecider(o),p.plotsPerBin=skipConf.plotsPerBin,p.skippingApplied=!0,p.dragHashMap=[],p.prevDrawInfo=n.slice(0),p}function updateDragMap(a={}){var b=a.component,c=a.eventArgs,d=b.getSkippingInfo&&b.getSkippingInfo()||{};c&&(d.dragHashMap[c.dataIndex]=c.endValue)}function dataSkipping(a={}){let b=a.component;decideSkip(a)?b.setSkippingInfo&&b.setSkippingInfo(skippingTool(a)):b.setSkippingInfo&&b.setSkippingInfo()}export default{dataSkipping:dataSkipping,updateDragMap:updateDragMap};