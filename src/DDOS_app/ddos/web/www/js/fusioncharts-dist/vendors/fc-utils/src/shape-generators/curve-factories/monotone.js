const getSign=a=>0>a?-1:1;class CurveMonotoneX{constructor(a){this._ctx=a}areaStart(){this._line=0}areaEnd(){this._line=NaN}lineStart(){this._x0=this._x1=NaN,this._y0=this._y1=NaN,this._t0=NaN,this._point=0}lineEnd(){switch(this._point){case 2:this._ctx.lineTo(this._x1,this._y1);break;case 3:this._monotoneCurveTo(this._t0,this._slope2(this._t0));}(this._line||0!==this._line&&1===this._point)&&this._ctx.closePath(),this._line=1-this._line}point(a,b){let c=NaN;if(a=+a,b=+b,a!==this._x1||b!==this._y1){switch(this._point){case 0:this._point=1,this._line?this._ctx.lineTo(a,b):this._ctx.moveTo(a,b);break;case 1:this._point=2;break;case 2:this._point=3,c=this._slope3(a,b),this._monotoneCurveTo(this._slope2(c),c);break;default:c=this._slope3(a,b),this._monotoneCurveTo(this._t0,c);}this._x0=this._x1,this._x1=a,this._y0=this._y1,this._y1=b,this._t0=c}}_monotoneCurveTo(a,b){let c=this._x0,d=this._y0,e=this._x1,f=this._y1,g=(e-c)/3;this._ctx.bezierCurveTo(c+g,d+g*a,e-g,f-g*b,e,f)}_slope2(a){var b=this._x1-this._x0;return b?(3*(this._y1-this._y0)/b-a)/2:a}_slope3(a,b){var c=Math.abs,d=this._x1-this._x0,e=a-this._x1,f=(this._y1-this._y0)/(d||void 0),g=(b-this._y1)/(e||void 0);return(getSign(f)+getSign(g))*Math.min(c(f),c(g),.5*c((f*e+g*d)/(d+e)))||0}}export default CurveMonotoneX;